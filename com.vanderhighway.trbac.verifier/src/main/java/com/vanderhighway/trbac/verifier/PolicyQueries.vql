/*******************************************************************************
 * Policy Queries
 *******************************************************************************/
package com.vanderhighway.trbac.verifier

import "https://vanderhighway.com/trbac/2020"
import "http://www.eclipse.org/emf/2002/Ecore"
import java ^java.util.Set
//import java ^java.util.HashSet
import java ^com.vanderhighway.trbac.aggregators.distinct
import java ^com.vanderhighway.trbac.aggregators.TimeRangeGroupSet

// Policy
pattern policyP(policy: Policy) {
    Policy(policy);
}

// Policy
pattern sessionP(session: Session) {
    Session(session);
}

// Example Constraint - All Role Names
pattern roleName(role: Role, name : java String) {
    Role.name(role,name);
}

// ----- Utility Patterns -----

pattern allJuniors(senior: Role, junior: Role) {
	Role.juniors(senior, junior);
} or {
	Role.juniors(senior, refjunior);
	find allJuniors(refjunior, junior);
}

pattern allJuniorsIncludingSelf(senior: Role, roleP: Role) {
	senior == roleP;
} or {
	find allJuniors(senior, roleP);
}

pattern allSubdemarcations(supdemarcation: Demarcation, subdemarcation: Demarcation) {
	Demarcation.subdemarcations(supdemarcation, subdemarcation);
} or {
	Demarcation.subdemarcations(supdemarcation, refsubdemarcation);
	find allSubdemarcations(refsubdemarcation, subdemarcation);
}

pattern allSubDemarcationsIncludingSelf(supdemarcation: Demarcation, demarcationP: Demarcation) {
	supdemarcation == demarcationP;
} or {
	find allSubdemarcations(supdemarcation, demarcationP);
}

// ----------------------------


// ----- Access Relation -----

pattern accessRelation(user: User, permission: Permission) {
    User.UR(user,role);
    Role.RD(role, demarcation);
   	Demarcation.DP(demarcation, permission);
}

pattern accessRelationWithHierarchies(user: User, permission: Permission) {
    User.UR(user,role);
    find allJuniorsIncludingSelf(role, roleP);
    Role.RD(roleP, demarcation);
    find allSubDemarcationsIncludingSelf(demarcation, demarcationP);
   	Demarcation.DP(demarcationP, permission);
}

// ---------------------------

// ----- Example Cardinality Constraints -----

pattern userShouldHaveARole(user: User) {
    neg User.UR(user, _);
}
pattern roleShouldHaveADemarcation(role: Role) {
    neg Role.RD(role, _);
}
pattern demarcationShouldHaveAPermission(dem: Demarcation) {
    neg Demarcation.DP(dem, _);
}

pattern onlyOneDirector(role:Role) {
	Role.name(role, "Director");
	n == count Role.RU(role, _);
	check(n >= 2);
}

pattern onlyOneRnDManager(role:Role) {
	Role.name(role, "RnD_Manager");
	n == count Role.RU(role, _);
	check(n >= 2);
}

pattern onlyOneOperationsManager(role:Role) {
	Role.name(role, "Operations_Manager");
	n == count Role.RU(role, _);
	check(n >= 2);
}

// ------------------------------------------


// ----- Example Static SoD constraints -----

pattern SoDEmployeeAndContractor(userE: User, userC: User, employee : Role, contractor : Role) {
    Role.name(employee, "Employee");
    Role.name(contractor, "Contractor");
   	Role.RU(employee, userE);
   	Role.RU(contractor, userC);
    userE==userC;
}

pattern SoDEmployeeAndVisitor(userE: User, userV: User, employee : Role, visitor : Role) {
    Role.name(employee, "Employee");
    Role.name(visitor, "Visitor");
   	Role.RU(employee, userE);
   	Role.RU(visitor, userV);
    userE==userV;
}

// ------------------------------------------


// ----- Example Prerequiste Constraints -----

pattern PrerequisiteEverybodyHasAccessToLobby(user: User) {
	Permission.name(pLobby,"Lobby");
    neg find accessRelation(user, pLobby);
}

pattern PrerequisiteVaultImpliesOpenOffice(user: User) {
	Permission.name(pVault,"Vault");
	find accessRelation(user, pVault);
	Permission.name(pOpenOffice,"OpenOffice");
    neg find accessRelation(user, pOpenOffice);
}

// ------------------------------------------


// ---- Constrains for Transformations ----
pattern userShouldHaveASession(user: User) {
    neg User.US(user, _);
}

//pattern sessionShouldHaveAUser(session: User) {
//    neg User.US(_,session);
//}

pattern SessionOfUser(user: User, session: Session) {
    User.US(user, session);
}

pattern RangeP(daySchedule: DaySchedule, group: TimeRangeGroup, timeRange: TimeRange, out starttime: java Integer, out endtime: java Integer) {
	TimeRangeGroup(group);
	TimeRangeGroup.timeRanges(group,timeRange);
	DaySchedule.timeRanges(daySchedule, timeRange);
	TimeRange.start(timeRange,starttime);
	TimeRange.end(timeRange,endtime);
}

pattern DayOfWeekAndMonthSchedule(out weekSchedule: DayOfWeekSchedule, out monthSchedule: DayOfMonthSchedule) {
	DayOfWeekSchedule(weekSchedule);
	DayOfMonthSchedule(monthSchedule);
}

pattern DayOfWeekAndMonthScheduleTimeRange( weekSchedule: DayOfWeekSchedule, monthSchedule: DayOfMonthSchedule,  
	 wstr: DayScheduleTimeRange,  mstr: DayScheduleTimeRange,
	 starttime: java Integer,  endtime: java Integer) {
	find DayOfWeekAndMonthSchedule(weekSchedule, monthSchedule);
	DayOfWeekSchedule.dayScheduleTimeRanges(weekSchedule, wstr);
	DayOfMonthSchedule.dayScheduleTimeRanges(monthSchedule, mstr);
	DayScheduleTimeRange.start(wstr, wstr_start);
	DayScheduleTimeRange.start(mstr, mstr_start);
	DayScheduleTimeRange.end(wstr, wstr_end);
	DayScheduleTimeRange.end(mstr, mstr_end);

	check( (wstr_start <= mstr_start && mstr_start <= wstr_end) ||  (mstr_start <= wstr_start && wstr_start <= mstr_end));

	starttime == eval(Math.max(wstr_start, mstr_start));
	endtime == eval(Math.min(wstr_end, mstr_end));
}

pattern DateScheduleTimeRange(in yearDaySchedule: DayOfYearSchedule, in wstr: DayScheduleTimeRange, in mstr: DayScheduleTimeRange,
	in ystr: DayScheduleTimeRange, out starttime: java Integer, out endtime: java Integer) {
	DayOfYearSchedule.dayOfWeekSchedule(yearDaySchedule, weekSchedule);
	DayOfYearSchedule.dayOfMonthSchedule(yearDaySchedule, monthSchedule);
	DayOfYearSchedule.dayScheduleTimeRanges(yearDaySchedule, ystr);
	find DayOfWeekAndMonthScheduleTimeRange(weekSchedule, monthSchedule, wstr, mstr, dwtr_start, dwtr_end);
	starttime == dwtr_start;
	endtime == dwtr_end;
	DayScheduleTimeRange.start(ystr, ystr_start);
	DayScheduleTimeRange.end(ystr, ystr_end);
	
	check( (dwtr_start <= ystr_start && ystr_start <= dwtr_end) ||  (ystr_start <= dwtr_start && dwtr_start <= ystr_end));

	starttime == eval(Math.max(dwtr_start, ystr_start));
	endtime == eval(Math.min(dwtr_end, ystr_end));
}

pattern TimeRangeGroup_DateScheduleTimeRange(group: TimeRangeGroup, in yearDaySchedule: DayOfYearSchedule, out starttime: java Integer, 
	out endtime: java Integer
) {
	find DateScheduleTimeRange(yearDaySchedule, wstr, _, _, starttime, endtime);
	DayScheduleTimeRange.timeRanges(wstr, tr);
	TimeRangeGroup.timeRanges(group, tr);
} or {
	find DateScheduleTimeRange(yearDaySchedule,  _, mstr, _, starttime, endtime);
	DayScheduleTimeRange.timeRanges(mstr, tr);
	TimeRangeGroup.timeRanges(group, tr);
} or {
	find DateScheduleTimeRange(yearDaySchedule, _, _, ystr, starttime, endtime);
	DayScheduleTimeRange.timeRanges(ystr, tr);
	TimeRangeGroup.timeRanges(group, tr);
}

pattern DateScheduleTimeRange_TimeRangeGroup(in yearDaySchedule: DayOfYearSchedule, out starttime: java Integer, 
	out endtime: java Integer, group: TimeRangeGroup) {
		find TimeRangeGroup_DateScheduleTimeRange(group,yearDaySchedule,starttime,endtime);
	}

pattern DateScheduleTimeRange_To_TimeRangeGroupCombination(in yearDaySchedule: DayOfYearSchedule, out starttime: java Integer, 
	out endtime: java Integer, groups: java TimeRangeGroupSet) {
	find DateScheduleTimeRange(yearDaySchedule,  _, _, _, starttime, endtime);
	groups == distinct find DateScheduleTimeRange_TimeRangeGroup(yearDaySchedule, starttime, endtime, #group);
}

pattern TimeRangeGroupCollection(groups: java TimeRangeGroupSet) {
	find DateScheduleTimeRange_To_TimeRangeGroupCombination(_, _, _, groups);
}

pattern TimeRangeGroupCollectionHasGroup(groups: java TimeRangeGroupSet, group: TimeRangeGroup) {
	find DateScheduleTimeRange(ys, _, _, _, start, end);
	find DateScheduleTimeRange_To_TimeRangeGroupCombination(ys, start, end, groups);
	find DateScheduleTimeRange_TimeRangeGroup(ys, start, end, group);
}

pattern TimeRangeGroupCollectionEnabled(groups: java TimeRangeGroupSet, role: Role, demarcation: Demarcation) {
	find DateScheduleTimeRange_To_TimeRangeGroupCombination(_, _, _, groups);
	Role.RD(role,demarcation);
	maxEnabledPriority == max find EnabledPriority(groups, role, demarcation, #p);
	maxDisabledPriority == max find DisabledPriority(groups, role, demarcation, #p2);
	check(maxEnabledPriority >= maxDisabledPriority);
} or {
	find DateScheduleTimeRange_To_TimeRangeGroupCombination(_, _, _, groups);
	Role.RD(role,demarcation);
	find EnabledPriority(groups, role, demarcation, _);
	neg find DisabledPriority(groups, role, demarcation, _);
}

pattern EnabledPriority(groups: java TimeRangeGroupSet, role: Role, demarcation: Demarcation, priority: java Integer) {
	find TimeRangeGroupCollectionHasGroup(groups,group);
	TimeRangeGroup.periodicEvents(group, rule);
	PeriodicEvent.enable(rule, enabled);
	check(enabled);
	Role.constraintedBy(role, rule);
	Demarcation.constrainedBy(demarcation, rule);
	PeriodicEvent.priority(rule, priority);
}


pattern DisabledPriority(groups: java TimeRangeGroupSet, role: Role, demarcation: Demarcation, priority: java Integer) {
	find TimeRangeGroupCollectionHasGroup(groups,group);
	TimeRangeGroup.periodicEvents(group, rule);
	PeriodicEvent.enable(rule, false);
	PeriodicEvent.enable(rule, enabled);
	check(!enabled);
	Role.constraintedBy(role, rule);
	Demarcation.constrainedBy(demarcation, rule);
	PeriodicEvent.priority(rule, priority);
}


//pattern DayOfWeekAndMonthScheduleTimeRangeRangeGroup(out weekSchedule: DayOfWeekSchedule, out monthSchedule: DayOfMonthSchedule, 
//	out starttime: java Integer, out endtime: java Integer, group: TimeRangeGroup
//) {
//	find DayOfWeekAndMonthScheduleTimeRange(weekSchedule, monthSchedule, wstr, _, starttime, endtime);
//	DayScheduleTimeRange.timeRanges(wstr, tr);
//	TimeRangeGroup.timeRanges(group, tr);
//} or {
//	find DayOfWeekAndMonthScheduleTimeRange(weekSchedule, monthSchedule, _, mstr, starttime, endtime);
//	DayScheduleTimeRange.timeRanges(mstr, tr);
//	TimeRangeGroup.timeRanges(group, tr);
//}

//pattern DayScheduleTimeRangeGroup(in weekday: DayOfWeekSchedule, in yearday: DayOfMonthSchedule, 
//	out starttime: java Integer, out endtime: java Integer, groups: java Set) {
//	find DayOfWeekAndMonthScheduleTimeRange(weekday, yearday, wsr, ysr, starttime, endtime);
//	groups == distinct find DayOfWeekAndMonthScheduleTimeRangeRangeGroup(weekday, yearday, starttime, endtime, #group);
//}
//
//pattern DayScheduleTimeRangeGroup(name: java String, groups: java Set) {
//	find TimeRange(weekday, wsr, yearday, ysr, starttime, endtime);
//	groups == distinct find TimeRangeGroup(weekday, yearday, starttime, endtime, #group);
//}

//pattern TimeRangeGroupsDistinct(in weekday: DayOfWeekSchedule, in yearday: DayOfMonthSchedule, 
//	out starttime: java Integer, out endtime: java Integer, groups: java Set) {
//	find TimeRange(weekday, wsr, yearday, ysr, starttime, endtime);
//	groups == distinct find TimeRangeGroup(weekday, yearday, starttime, endtime, #group);
//}
//
//pattern DistinctGroups(groups: java Set) {
//	find TimeRangeGroupsDistinct(_, _, _, _, groups);
//}
//
//pattern TimeRangeGroupExceptAlways(in weekday: DayOfWeekSchedule, in yearday: DayOfMonthSchedule, 
//	out starttime: java Integer, out endtime: java Integer, group: TimeRangeGroup
//) {
//	find TimeRangeGroup(weekday,yearday,starttime,endtime,group);
//	TimeRangeGroup.name(group, name); 
//	check(name != "Always");
//}


//pattern starttime(day: Day, starttime: java Integer) {
//	Day.ranges(day, timeRange);
//	Range.starttime(timeRange, starttime);
//}
//
//pattern endtime(day: Day, endtime: java Integer) {
//	Day.ranges(day, timeRange);
//	Range.endtime(timeRange, endtime);
//}
//
//pattern bound(day: Day, bound: java Integer) {
//	find starttime(day, bound);
//} or {
//	find endtime(day, bound);
//}

//private pattern findValueInBetween(lr: Range, ur: Range){
//	Range.starttime(_,z);
//	Range.starttime(lr, starttime);
//	Range.endtime(ur, endtime);
//}

//private pattern starttimes(in day: Day, out starttime: java Integer) {
//
//}

//
//pattern InheritedDemarcation(role: Role, demarcation: Demarcation) {
//    Role.RDH(role, demarcation);
//}
//
//pattern MissingInheritedDemarcation(roleJunior: Role, roleSenior: Role, demarcation: Demarcation) {
//	find MissingDirectInheritedDemarcation(roleJunior, roleSenior, demarcation);
//	} or {
//	find MissingIndirectInheritedDemarcation(roleJunior, roleSenior, demarcation);
//}
//
//pattern MissingDirectInheritedDemarcation(roleJunior: Role, roleSenior: Role, demarcation: Demarcation) {
//	Role.juniors(roleSenior, roleJunior);
//	Role.RD(roleJunior,demarcation);
//	neg Role.RDH(roleSenior, demarcation);
//}
//
//pattern MissingIndirectInheritedDemarcation(roleJunior: Role, roleSenior: Role, demarcation: Demarcation) {
//	Role.juniors(roleSenior, roleJunior);
//	Role.RDH(roleJunior, demarcation);
//	neg Role.RDH(roleSenior,demarcation);
//}
// ----------------------------------------


//pattern ScheduleRangeP(timeRange: ScheduleRange, out starttime: java Integer, out endtime: java Integer) {
//	ScheduleRange(timeRange);
//	ScheduleRange.start(timeRange,starttime);
//	ScheduleRange.end(timeRange,endtime);
//}
//
//pattern emapPattern(K : EString, V : EString) {
//    Policy(P);
//    Policy.map(P, Map);
//    EStringToEStringMap.key(Map, K);
//    EStringToEStringMap.value(Map, V);
//}
