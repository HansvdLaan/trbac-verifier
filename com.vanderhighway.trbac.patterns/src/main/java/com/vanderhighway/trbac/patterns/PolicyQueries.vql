/*******************************************************************************
 * Policy Queries
 *******************************************************************************/

package com.vanderhighway.trbac.patterns

import "https://vanderhighway.com/trbac/2020"
import "http://www.eclipse.org/emf/2002/Ecore"
//import java ^java.util.Set
//import java ^java.util.HashSet
import java ^com.vanderhighway.trbac.aggregators.distinct
import java ^com.vanderhighway.trbac.aggregators.Scenario

// Example Constraint - All Role Names
pattern roleName(role: Role, name : java String) {
    Role.name(role,name);
}

// ----- Utility Patterns -----

pattern allJuniors(senior: Role, junior: Role) {
	Role.juniors+(senior, junior);
}

pattern allJuniorsIncludingSelf(senior: Role, junior: Role) {
	Role.juniors*(senior, junior);
}

pattern allSubdemarcations(supdemarcation: Demarcation, subdemarcation: Demarcation) {
	Demarcation.subdemarcations+(supdemarcation, subdemarcation);
}

pattern allSubDemarcationsIncludingSelf(supdemarcation: Demarcation, subdemarcation: Demarcation) {
    Demarcation.subdemarcations*(supdemarcation, subdemarcation);
}

// ----------------------------


// ----- Access Relation -----

//pattern accessRelationSimple(user: User, permission: Permission) {
//    User.UR(user,role);
//    Role.RD(role, demarcation);
//   	Demarcation.DP(demarcation, permission);
//}
//
//pattern accessRelationWithHierarchies(user: User, permission: Permission) {
//    User.UR(user,role);
//    find allJuniorsIncludingSelf(role, roleP);
//    Role.RD(roleP, demarcation);
//    find allSubDemarcationsIncludingSelf(demarcation, demarcationP);
//   	Demarcation.DP(demarcationP, permission);
//}

pattern accessRelation(user: User, scenario: java Scenario, permission: Permission) {
    User.UR(user,role);
    Role.juniors*(role, roleP);
    find Scenarios(scenario);
    find RSD(roleP, scenario, demarcation);
    find allSubDemarcationsIncludingSelf(demarcation, demarcationP);
    Demarcation.subdemarcations*(demarcation, demarcationP);
    Demarcation.DP(demarcationP,permission);
}

// ---------------------------

// ----- Example Cardinality Constraints -----

pattern userShouldHaveARole(user: User) {
    neg User.UR(user, _);
}

pattern roleShouldHaveADemarcation(role: Role) {
    neg Role.RD(role, _);
}
pattern demarcationShouldHaveAPermission(dem: Demarcation) {
    neg Demarcation.DP(dem, _);
}

pattern onlyOneDirector(role:Role) {
	Role.name(role, "Director");
	n == count Role.RU(role, _);
	check(n >= 2);
}

pattern onlyOneRnDManager(role:Role) {
	Role.name(role, "RnD_Manager");
	n == count Role.RU(role, _);
	check(n >= 2);
}

pattern onlyOneOperationsManager(role:Role) {
	Role.name(role, "Operations_Manager");
	n == count Role.RU(role, _);
	check(n >= 2);
}

// ------------------------------------------


// ----- Example Static SoD constraints -----

pattern SoDEmployeeAndContractor(userE: User, userC: User, employee : Role, contractor : Role) {
    Role.name(employee, "Employee");
    Role.name(contractor, "Contractor");
   	Role.RU(employee, userE);
   	Role.RU(contractor, userC);
    userE==userC;
}

pattern SoDEmployeeAndVisitor(userE: User, userV: User, employee : Role, visitor : Role) {
    Role.name(employee, "Employee");
    Role.name(visitor, "Visitor");
   	Role.RU(employee, userE);
   	Role.RU(visitor, userV);
    userE==userV;
}

// ------------------------------------------


// ----- Example Prerequiste Constraints -----

//pattern PrerequisiteEverybodyHasAccessToLobby(user: User) {
//	Permission.name(pLobby,"Lobby");
//    neg find accessRelation(user, pLobby);
//}
//
//pattern PrerequisiteVaultImpliesOpenOffice(user: User) {
//	Permission.name(pVault,"Vault");
//	find accessRelation(user, pVault);
//	Permission.name(pOpenOffice,"OpenOffice");
//    neg find accessRelation(user, pOpenOffice);
//}
// ------------------------------------------

pattern RangeP(daySchedule: DaySchedule, context: TemporalContext, instance: TimeRange, out starttime: java Integer, out endtime: java Integer) {
	TemporalContext(context);
	TemporalContext.instances(context,instance);
	DaySchedule.timeRanges(daySchedule, instance);
	TimeRange.start(instance,starttime);
	TimeRange.end(instance,endtime);
}

pattern DayOfWeekAndMonthSchedule(out dayOfWeekSchedule: DayOfWeekSchedule, out dayOfMonthSchedule: DayOfMonthSchedule) {
	DayOfWeekSchedule(dayOfWeekSchedule);
	DayOfMonthSchedule(dayOfMonthSchedule);
}

pattern DayOfWeekAndMonthScheduleInstance(dayOfWeekSchedule: DayOfWeekSchedule, dayOfMonthSchedule: DayOfMonthSchedule,  
	 wstr: DayScheduleTimeRange,  mstr: DayScheduleTimeRange,
	 starttime: java Integer,  endtime: java Integer) {
	find DayOfWeekAndMonthSchedule(dayOfWeekSchedule, dayOfMonthSchedule);
	DayOfWeekSchedule.instances(dayOfWeekSchedule, wstr);
	DayOfMonthSchedule.instances(dayOfMonthSchedule, mstr);
	DayScheduleTimeRange.start(wstr, wstr_start);
	DayScheduleTimeRange.start(mstr, mstr_start);
	DayScheduleTimeRange.end(wstr, wstr_end);
	DayScheduleTimeRange.end(mstr, mstr_end);

	check( (wstr_start <= mstr_start && mstr_start <= wstr_end) ||  (mstr_start <= wstr_start && wstr_start <= mstr_end));

	starttime == eval(Math.max(wstr_start, mstr_start));
	endtime == eval(Math.min(wstr_end, mstr_end));
}


pattern DateScheduleInstance(in dayOfYearSchedule: DayOfYearSchedule, in wstr: DayScheduleTimeRange, in mstr: DayScheduleTimeRange,
	in ystr: DayScheduleTimeRange, out starttime: java Integer, out endtime: java Integer) {
	DayOfYearSchedule.dayOfWeekSchedule(dayOfYearSchedule, dayOfWeekSchedule);
	DayOfYearSchedule.dayOfMonthSchedule(dayOfYearSchedule, dayOfMonthSchedule);
	find DayOfWeekAndMonthScheduleInstance(dayOfWeekSchedule, dayOfMonthSchedule, wstr, mstr, wmtr_start, wmtr_end);
	
	DayOfYearSchedule.instances(dayOfYearSchedule, ystr);
	DayScheduleTimeRange.start(ystr, ystr_start);
	DayScheduleTimeRange.end(ystr, ystr_end);
	
	check( (wmtr_start <= ystr_start && ystr_start <= wmtr_end) ||  (ystr_start <= wmtr_start && wmtr_start <= ystr_end));

	starttime == eval(Math.max(wmtr_start, ystr_start));
	endtime == eval(Math.min(wmtr_end, ystr_end));
}

pattern TemporalContext_DateScheduleTimeRangeInstance(context: TemporalContext, in dayOfYearSchedule: DayOfYearSchedule, 
	out starttime: java Integer, out endtime: java Integer
) {
	find DateScheduleInstance(dayOfYearSchedule, wstr, _, _, starttime, endtime);
	DayScheduleTimeRange.temporalContextTimeRanges(wstr, tr);
	TemporalContext.instances(context, tr);
} or {
	find DateScheduleInstance(dayOfYearSchedule,  _, mstr, _, starttime, endtime);
	DayScheduleTimeRange.temporalContextTimeRanges(mstr, tr);
	TemporalContext.instances(context, tr);
} or {
	find DateScheduleInstance(dayOfYearSchedule, _, _, ystr, starttime, endtime);
	DayScheduleTimeRange.temporalContextTimeRanges(ystr, tr);
	TemporalContext.instances(context, tr);
}

pattern DateScheduleTimeRangeInstance_TemporalContext(in yearDaySchedule: DayOfYearSchedule, out starttime: java Integer, 
	out endtime: java Integer, context: TemporalContext) {
		find TemporalContext_DateScheduleTimeRangeInstance(context,yearDaySchedule,starttime,endtime);
}
	
pattern DateScheduleTimeRange_To_Scenario(in yearDaySchedule: DayOfYearSchedule, out starttime: java Integer, 
	out endtime: java Integer, scenario: java Scenario) {
	find DateScheduleInstance(yearDaySchedule,  _, _, _, starttime, endtime);
	scenario == distinct find DateScheduleTimeRangeInstance_TemporalContext(yearDaySchedule, starttime, endtime, #context);
}

pattern Scenarios(scenario: java Scenario) {
	find DateScheduleTimeRange_To_Scenario(_, _, _, scenario);
}

pattern ScenarioTemporalContext(scenario: java Scenario, context: TemporalContext) {
	find DateScheduleInstance(ys, _, _, _, start, end);
	find DateScheduleTimeRange_To_Scenario(ys, start, end, scenario);
	find DateScheduleTimeRangeInstance_TemporalContext(ys, start, end, context);
}

pattern connectedByTemporalGrantRule(role: Role, demarcation: Demarcation) {
	TemporalGrantRule.role(rule, role);
	TemporalGrantRule.demarcation(rule, demarcation);
}

pattern RSD(role: Role, scenario: java Scenario, demarcation: Demarcation) {
	find Scenarios(scenario);
	find connectedByTemporalGrantRule(role, demarcation);
	maxEnabledPriority == max find EnabledPriority(scenario, role, demarcation, #p);
	maxDisabledPriority == max find DisabledPriority(scenario, role, demarcation, #p2);
	check(maxEnabledPriority >= maxDisabledPriority);
} or {
	find Scenarios(scenario);
	find connectedByTemporalGrantRule(role, demarcation);
	find EnabledPriority(scenario, role, demarcation, _);
	neg find DisabledPriority(scenario, role, demarcation, _);
}

pattern EnabledPriority(scenario: java Scenario, role: Role, demarcation: Demarcation, priority: java Integer) {
	find ScenarioTemporalContext(scenario,context);
	TemporalContext.temporalGrantRules(context, rule);
	TemporalGrantRule.enable(rule, enabled);
	check(enabled);
	Role.constrainedBy(role, rule);
	Demarcation.constrainedBy(demarcation, rule);
	TemporalGrantRule.priority(rule, priority);
}

pattern DisabledPriority(scenario: java Scenario, role: Role, demarcation: Demarcation, priority: java Integer) {
	find ScenarioTemporalContext(scenario,context);
	TemporalContext.temporalGrantRules(context, rule);
	TemporalGrantRule.enable(rule, enabled);
	check(!enabled);
	Role.constrainedBy(role, rule);
	Demarcation.constrainedBy(demarcation, rule);
	TemporalGrantRule.priority(rule, priority);
} 


pattern Reachable(building: Building, zone: SecurityZone) {
	Building(building);
	Building.securityzones(building,zone);
	SecurityZone.public(zone, true);
} or {
	find Reachable(building, z);
	SecurityZone.reachable(z, zone);
}

pattern ReachableAccess(user: User, scenario: java Scenario, zone: SecurityZone) {
    SecurityZone.public(zone, true);
    User(user);
    find Scenarios(scenario);
} or {
	find ReachableAccess(user, scenario, z);
	SecurityZone.reachable(z, zone);
	find accessRelation(user, scenario, permission);
	Permission.PO(permission, zone);
}

pattern UnreachableAccess(user: User, scenario: java Scenario, zone: SecurityZone) {
    find accessRelation(user, scenario, permission);
    Permission.PO(permission, zone);
    neg find ReachableAccess(user, scenario, zone);
}


